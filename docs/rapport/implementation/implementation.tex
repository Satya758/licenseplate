\section{Implementering}
\label{sec:implementation}

I dette afsnit gennemgår vi implementeringssdetaljer i de funktioner som vores system består af. I flere af funktionerne har vi brugt Matlabs indbyggede funktioner, hvis vi kendte til kommandoer... F.eks. filter og blokprocess. I første delafsnit gennemgås nogle hjælpefunktioner som bruges i flere elementer af systemet. Dernæst gennemgås funktionerne til lokalisering af nummerplader, separation af tegn og til sidst genkendelse af tegn.

Det skal bemærkes at koordinatsystemet der bruges i Matlab ikke har origo i det samme punkt som det man kender som et almindeligt koordinatsystem. Origo ligger derimod i øverste venstre hjørne (normalt ligger det i nederste venstre hjørne). Desuden er koordinaterne til origo i Matlab 1,1 og ikke 0,0. y-koordinaten til et punkt i Matlab angives normalt først, så en pixel i et billede refereres til med koordinaterne y,x i modsætning til den oftest anvendte rækkefølge x,y.

%%%%%%%%%%%%%%%%%%%%%%%%
%%% HJÆLPEFUNKTIONER %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hjælpefunktioner}
De følgende hjælpefunktioner bruges af flere funktioner.
\subsubsection{Hjælpefunktion 1}
BinImgCleanup
\subsubsection{Hjælpefunktion 2}
GetBestCandidate
\subsubsection{Hjælpefunktion 3}
ContrastStretch
\subsubsection{Hjælpefunktion 4}
WhiteLine 
\subsubsection{Hjælpefunktion 3}
Distribution

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LOKALISERING AF NUMMERPLADER %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lokalisering af nummerplader}
I de følgende afsnit gennemgår vi væsentlige implementeringssdetaljer i de funktioner vi bruger til lokalisering af nummerplader. De tager alle stien til et \textit{JPEG}-billede som inddata og leverer koordinater til en enkelt nummerpladekandidat som uddata. Koordinaterne der beskriver nummerpladekandidatens position i inddata-billedet angives i rækkefølgen: Mindste \textit{x}-værdi, største \textit{x}-værdi, mindste \textit{y}-værdi og største \textit{y}-værdi. Hvis en funktion ikke kan finde en nummerpladekandidat returneres et koordinatsæt hvor alle værdier er $0$.

Ofte udvider vi kandidatområdet for at få hele pladen med. Det er vigtigt for at kunne rotere (mere om dette i afsnit \vref{sec:implementation/sep/rotation}).

Vi har brugt greythresh med mindre andet er beskrevet.

\subsubsection{Analyse af interesseområder}
Analysen af de binære billeder der markerer interesseområder varetages af funktionen \textit{BinImgCleanup} hvis kildekode findes i afsnit \vref{BinImgCleanup}. Funktionen tager et binært billede som inddata, og returner et binært billede hvor de områder der sandsynligvis ikke er nummerpladeområder er fjernet som beskrevet i afsnit \vref{sec:BinImgCleanup}. 


\subsubsection{Metode: Områder domineret af lyse gråtoner}
Denne metode er implementeret i funktionen \textit{DetectSameness} hvis kildekode findes i afsnit \vref{code:DetectSameness}. Programmet udfører følgende trin:

\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Skab binært billede som beskrevet i \ref{sec:DetectSameness}.
\item[5.] Sammentræk områder i det binære billede\footnote{Eng.: Erode}
\item[6.] Forbind områder der ligger ved siden af hinanden i det binære billede\footnote{Eng.: Dilate}.
\item[7.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[8.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[9.] Returner koordinater.
\end{description}

I trin nr. 5 sammentrækker vi med et kvadratisk element. I trin nr. 6 forbinder vi områder der ligger ved siden af hinanden ved at udvide med et liggende rektangulært element. 


\subsubsection{Metode: Områder med høj kontrast}
Denne metode er implementeret i funktionen \textit{DetectContrastAvg} hvis kildekode findes i afsnit \vref{code:DetectContrastAvg}. Programmet udfører følgende trin:

\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[3.] SKAL DER VÆRE LOG HER? DET ER DER I KODEN!!
\item[4.] Gør billedet lysere ved at dividere intensiteterne med en konstant.
\item[5.] Udregn gradienter.
\item[6.] Udregn gradienters vinkler.
\item[7.] Udregn gradienters længder og normaliser dem så de største har længden 1,0.
\item[8.] Udvælg gradienter hvis normaliserede længde er 0,25 eller mere.
\item[9.] Skab et billede ved at indsætte intensitetet af punkter der har "liggende" gradienter. Det vil sige, gradienter der har en vinkel på mellem 0 og 30 i forhold til vandret. Hvis gradienten er en af de længste i billedet, indsættes den fordoblede intensitet.
\item[10.] Kør et filter som udtværer billedet og forbinder områder der ligger ved siden af hinanden som beskrevet i afsnit \ref{sec:DetectContrastAvg}.
\item[11.] Skab et binært billede udfra det filtrerede billede af de "liggende" gradienter. 
\item[12.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[13.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[14.] Returner koordinater.
\end{description}

Vi bruger Matlabs funktioner til at udregne gradienterne samt anvende filteret.


Pladerne bliver meget lave da vi kun kigger på kontrasten. Vi får altså ikke den hvide over- og underkant med. Derfor udvider vi kandidaten med 15 pixels på over- og underkanten. 


\subsubsection{Metode: Frekvensanalyse}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectPlateness}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[6.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I punkt 8 returnerer vi et kandidatområde der er gjort højere da vi ellers ofte ikke får hele pladen med, da frekvensen i det hvide område over og under tegnene i nummerpladen er lav og dermed ikke karateristisk for en nummerplade.

Metoden bliver dårligere jo mere man skalerer billedet ned da tegn i nummerpladerne ikke længere er klart separeret. Vi burde nok køre dette på større billeder.
Vi bruger funktionen plateness. Den kunne være mere robust.

FIGURER AF HISTOGRAMMER OG LIGN.


\subsubsection{Metode: Skru op for Kontrast}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectCStretch}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[8.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I trin 4 bruger vi hjælpefunktionen \textit{ContrastStretc} i en dobbeltløkke der behandler billedet i kvadratiske blokke af 4x4 pixels. Når vi skaber det binære billede i trin 5 bruger vi en grænseværdi på 0,65 der gør at det hvide i det binære billede skal være pixels der er noget over middelværdien i det filtrerede billede. Vores erfaring er, at vi i mange tilfælde kan separere nummerpladerne bedre med denne grænseværdi.

ER DET BEDRE AT GANGE GRAYTHRESH LIDT OP??    
GØR VI KANDIDATEN STØRRE?
Måske kunne vi opnå bedre resultater ved at bruge filter frem for blok, men blok er meget hurtigere.


%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Metode: Kvantifisering}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectQuant}.
\item[5.] Sæt antal forskellige intensiteter i billedet ned til 7.
\item[6.] Lav et binært billede for hver af intensiteterne.
\item[7.] For hver intensitet, slet områder i det binære billeder der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[8.] Gør områderne i de binære billeder lidt mindre.  
\item[9.] Slå de binære billeder sammen til et enkelt binært billede. 
\item[10.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[11.] Udvid koordinaterne for den valgte nummerpladekandidat.
\item[12.] Returner koordinater.
\end{description}

I trin 4 dividerer vi alle intensiteterne i billedet med 43 og runder af for at sætte antallet af mulige intensitetsværdier ned til 7 i intervallet 1 til 7. De binære billeder i trin 6 gemmer vi en matrix med dimensionerne \textit{[billedehøjde, billedbrede, antal intensiteter]}. I trin 8 gør vi områderne mindre så se ikke smelter sammen med andre områder i trin 9.

METODEN ER DÅRLIG PÅ HVIDE BILER



%\subsubsection{Metode: Histogram}

\subsubsection{Endeligt valg af nummerpladekandidat}
\begin{description}
\item[1.] Indlæs billede.
\end{description}


Illustrer hvordan vi afgør (u)enighed. 

GØR NOGET I KODEN DA RESULTATET 2 vs 2 kandidater er random.

VI RETURNERER DEN STØRST MULIGE PLADE

\subsubsection{Mulige forbedringer}
Vi kunne køre GetBestCandidate når der er uenighed i DetectMain.
Vi kunne lave et pointsystem i GetBestCandidate.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SEPARATION AF TEGN %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Separation af tegn}

I de følgende afsnit gennemgår vi væsentlige implementeringssdetaljer i de funktioner vi bruger til separation af tegn. 

\subsubsection{Rotation}
\label{sec:implementation/sep/rotation}

Metoden til rotation er implementeret i funktionen \textit{RotatePlateRadon}, hvis kildekode findes i afsnit \vref{code:RotatePlateRadon}. Metoden tager stien til et \textit{JPEG}-billede samt koordinaterne for nummerpladen i billedet som indata. Funktionen returnerer billedet af den roterede plade samt dennes (roterede) koordinater i original billedet. Funktionens forløb er som følger:

\paragraph{1. Billedet af nummerpladen "tages ud" af originalbilledet.}
\paragraph{2. Billedet af pladen kant-detekteres:}
For at finde pladens rotation er det nødvendigt at finde kanterne i billedet af nummerpladen. Matlab funktionen \textit{edge} bruges til at lave et binært billede hvor alle horisontale kanter er markeret. De vertikale kanter markeres ikke. På denne måde kan vi nøjes med at analysere én dimension ved brug af Radon transformationen. I denne sammenhæng er vi interesseret i de kanter der er (næsten) horisontale, da det med stor sandsynlighed er de "lange" kanter i nummerpladens rektangel. Det vil være et problem, hvis nummerpladen "klippes" så tæt at den øvre eller nedre kant af nummerpladen ikke kommer med i billedet. I dette tilfælde er det meget usikkert om de horisontale kanter i nummerpladens tegn vil være kraftige nok til at Radon transformationen vil "bruge" disse kanter til at finde den tydeligste kant.

\paragraph{3. Radon matricen for kant-billedet findes ved brug af Matlab funktionen \textit{radon}.}

\paragraph{4. Den maksimale værdi i Radon matricen findes og rotationsvinklen registres:}
Rotationsvinklen svarer til ...

\paragraph{5. Billedet af nummerpladen roteres ved brug af \textit{imrotate}.}
\paragraph{6. Koordinaterne til den roterede plade findes ved brug af en rotationsmatrix.}

\subsubsection{Separation}

Metoderne til separation af tegn tager et billede af en nummerplade samt koordinaterne til denne plade i orginalbilledet som inddata, og returnerer syv billeder af de syv tegn (hvis syv tegn er fundet), koordinaterne til disse tegn i orginalbilledet samt antallet af fundne tegn som uddata.

\subsubsection*{Sammenhængende komponenter}

Denne metode er implementeret i funktionen \textit{CharSeparationCC}, hvis kildekode findes i afsnit \vref{code:CharSeparationCC}. Funktionen forløber således:

\paragraph{1. Billedet af pladen omdannes til gråtone.}

\paragraph{2. Billedet laves om til sort-hvid, "roughly" og indskrænkes til den største komponent:}
De billeder der i denne del af systemet modtages fra metoderne til identificering af nummerplader er ikke nødvendigvis udskåret så nøjagtigt at nummerpladen dækker hele billedet. Billedet kan derfor indeholde elementer som ikke er en del af nummerpladen (eksempelvis et klistermærke som sidder på bilen). Derfor er det hensigtsmæssigt, når tegnene i nummerpladen skal separeres, at indskrænke billedet så det mest muligt kun forestiller nummerpladen. Da nummerpladen med sandsynlighed er det mest lyse element i billedet, gøres dette ved at gøre billedet binært og indskrænke det til det største hvide område i billedet. Dette gøres ved hjælp af Matlab funktionen im2bw, hvor grænsen for hvilke intensitetsværdier der skal være hvide i det binære billede sættes under middel. På denne måde sikrer vi os, at nummerpladen vil være hvid og at den ikke bliver sort (SKRIV OM).

\paragraph{3. Kontrast..:}
For at få nummerpladens tegn til at adskille sig mest muligt fra pladens hvide baggrund skal billedet kontrastforstærkes. Til at kontrastforstærke bruges hjælpefunktionen \textit{ContrastStretch}. Denne funktion udføres i blokke så man udover den forstærkede kontrast mellem tegnene og baggrunden også opnår forstærket kontrast mellem støj (f.eks. snavs på nummerpladen) og baggrunden. Hvis denne støj er tæt på et tegn vil der være chance for at tegnet "gror sammen" med støjen og derfor bliver sorteret fra når de sammenhængende komponenter analyseres. Hvis kontrasten forstærkes i blokke er der dog en mulighed for at snavsen og tegnets kant vil blive adskilt. Størrelsen af blokkene der arbejdes med er bestemt eksperimentielt.

\paragraph{4. Tynde komponenter i toppen og i siderne af billedet fjernes:}
Når det binære billede er dannet opstår der igen en mulighed for at minimere tilfælde hvor tegn er groet sammen med eksempelvis nummerpladens kant. Se et eksempel nedenfor... Når dette .... Derfor slettes alle pixels som har en tom plads på begge sider i den øverste 1/3 af billedet, samt i den yderste 1/10 i både højre og venstre side.

BILLEDE MED NUMMERPLADE SOM ER I SKYGGE FOROVEN SAMT BINÆRT BILLEDE HVOR TYNDE KOMPONENTER KAN FJERNES

Derudover slettes alle pixels i de rækker af billedet som ikke har mindst en 1/10 eller højst 2/3 af alle pixels i billedets bredde sat. Dette gøres fordi en linie som går i gennem alle tegn vil ligge i dette område.

BESKRIV PROBLEM MED TEGNET K

\paragraph{5. Horisontale linier med meget lidt hvid, eller meget hvid gøres helt sorte:}
Beskrivelse...

\paragraph{6. Det sort-hvide billede laves til et sammenhængende-komponenter-billede.}
\paragraph{7. For små og for store komponenter fjernes.}
I næste del af funktionen frasorteres alle de sammenhængende komponenter der er for små eller for store.

\paragraph{8. Grupper på syv komponenter samles hvor alle syv komponenter har samme højde og er i samme højde.}

Så findes der grupper af syv sammenhængende komponenter hvor elementerne i hver gruppe skal være ca. lige høje og befinde sig i ca. samme højde.

\paragraph{9. Afstandene mellem komponenter i hver gruppe udregnes og en "god" gruppe vælges:}
Til sidst analyseres disse grupper og hvis komponenterne i én af grupperne har de rette afstande i mellem sig, vælges elementerne i gruppen som tegnene.

NOGET MED AT TEGNENE SKÆRES "TÆT"	

\subsubsection*{Bjerg/dal}

Denne metode er implementeret i funktionen \textit{CharSeparationPTV}, hvis kildekode findes i afsnit \vref{code:CharSeparationPTV}.


Nummerpladens signatur fås ved at summere projektionerne af alle rækkerne i billedet. Hvis denne signatur præsenteres som en graf i et koordinatsystem vil der forekomme toppe i de kolonner hvor der høj intensitet. Idéen er så at udvælge de otte højeste toppe som de otte steder i x-planen der skal skæres ved.

KONTRAST?

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Pladens signatur findes ved at opsummere intensitetsværdierne i billedet af nummerpladen omdannet til gråtone. Hvis man betragter signaturen som en graf vil den være "hakket" på grund af støj i billedet (dvs. det er kun i teorien at billedet kun indeholder en hvid baggrund og nogle mørke bogstaver, hvilket ville give en perfekt graf). Signaturen skal derfor udglattes. Dette gøres ved at tildele det indeværende punkt på grafen middelværdien af punktets nærområde. EKSEMPEL PÅ UDREGNING? Et eksempel på en "rå" graf og samme graf, udglattet ses i Figur \vref{fig:smoothSig}.

EKSEMPEL PÅ HAKKET SIGNATUR OG UDGLATTET SIGNATUR

\begin{figure}[htp]
\label{fig:smoothSig}
\caption{bla}
\end{figure}

For at finde de toppe hvor der skal skæres, leder vi efter punkter, $x$ i signaturgrafen hvor de $n$ forrige punkter har haft stigende værdier op til $x$ og hvor de efterfølgende $n$ punkter har faldende værdier. DETTE GØR VI IKKE I PRAKSIS! SKAL LAVES OM. De otte $x$'er som har de otte højeste værdier vælges som de otte skæringspunkter.

NOGET OM HVORDAN VI FINDER TOP OG BUND BESKÆRING


\subsubsection{Mulige forbedringer}
DER MÅ VÆRE MANGE KOMMENTARER TIL HVORDAN VI KAN GØR BJERG/DAL BEDRE

I funktionen der bruger sammenhængende komponenter findes der flere statiske variable, som eksempelvis størrelsen af de blokke der kontrastforstærkes i, komponenternes minimum bredde osv. Disse variable kunne være lavet dynamisk, men de er ret gode nu og derfor har vi ladet dem være. SKRIV DET SIDSTE OM.

CONCOMP: BESKREVET I KWAS: MAN KU FJERNE KANTER FØR ANALYSE?

SKALERING KAN FORBEDRE HASTIGHED? PERFORMANCE?

MEDIAN FILTER ELLER ANDRE FILTRE? LYSFORSTÆRKNING?


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GEKENDELSE AF TEGN %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Genkendelse af tegn}

\subsubsection{Middelvektorer}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Implementationen af metoden til tegngenkendelse ved hjælp af vektor analyse findes i filerne \textit{GetMeanVectors.m} og \textit{ReadPlateFV.m}.

For at disse to funktioner/metoder skal fungere sammen er det nødvendigt at længden, $d$ af middelvektorerne er den samme i begge funktioner. Man bør eksperimentere med størrelsen af $d$.

\textit{GetMeanVectors.m} udarbejder en matrix bestående af middelvektorer for hvert lovligt tegn. Hver vektor vil have længden $d$. Denne matrix bruges af \textit{ReadPlateFV.m}: Hvert inputbillede omformes til en vektor af længden $d$ og herefter løbes middelvektor-matrixen igennem. Afstanden fra det omformede billede til hver middelvektor noteres og tegnhitlisten udarbejdes på baggrund af disse afstande. Sammen med denne hitliste returneres afstandene, så disse kan bruges i forbindelse med syntaks analyse.
Som input modtager funktionen en mængde billeder af manuelt sorterede tegn.

Hvert billede laves til et kvadrat. Ved at lave middelvektorer på træningssættet kan vi se at man ikke kan have vektorer af længden 4, da flere bogstavs vektorer så vil være de samme (nemlig 0 0 0 0). Afprøv med andre længder.

\textit{ReadPlateFV.m}...

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Sum-billeder}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Syntaks analyse}

Metoden til syntaks analyse tager tegnhitlisterne for de syv tegn, listerne over afstandene til middelvektorerne samt et "maksimal-hit-nummer" som inddata. Uddata er en syntaksanalyseret tegnfølge samt en vektor indeholdende de hits der er blevet brugt til at lave denne tegnfølge. Implementeringen af metoden til syntaksanalyse findes i filen \textit{SyntaxAnalysis.m}.

Funktionens forløb er som følger:

\begin{description}
\item[1.] Hitlisterne for tegnene på de to første pldser gennemløbes indtil der står to bogstaver
\item[2.] De to tegn på de første to pladser analyseres og udskiftes om nødvendigt
\end{description}

Hvis der i på tegnfølgens to første positioner fremkommer en ulovlig bogstavkombination fås et problem: Hvilket tegn skal man forsøge at udskifte så en lovlig kombination forekommer? Dette gøres på baggrund af billedets (af tegnet) afstand til de to middelvektorer: Den middelvektor der er længst væk har størst sandsynlighed for at være et forkerte bogstav, hvorfor denne skiftes ud.

\begin{description}
\item[3.] Hitlisterne for tegnene på de fem sidste pladser gennemløbes indtil der står fem tal
\item[4.] De to tegn på plads nr. tre og fire analyseres og udskiftes om nødvendigt
\end{description}

Bla bla

\begin{description}
\item[5.] De valgte hitnumre analyseres. Hvis et nummer er for højt i forhold til det maksimale, returnes et "\_" tegn på den givne plads
\end{description}

\subsubsection{Mulige forbedringer}
Når der eksempelvis forekommer en ulovlig bogstavkombination i syntaksanalysen udskiftes det tegn som har den længste afstand til middelvektoren hver gang. Det vil sige at kun det ene tegn vil blive udskiftet (tegnets vektor er til at starte med den vektor der ligger længest væk og dette vil ikke ændre sig, da man hele tiden vælger vektorer der ligger længere og længere væk). En anden mulighed kunne være at man skifter mellem at udskifte det ene og det andet tegn Eksempel: tegnfølgen \textbf{AB} er fundet, men denne er ulovlig. Først udskiftes \textbf{B}, da denne ligger længst væk. En ny tegnfølge \textbf{AC} findes, men denne er også ulovlig. I stedet for at udskifte tegnet på 2. position igen (\textbf{C}) udskiftes \textbf{A} og \textbf{B} sættes tilbage på 2. position.

Man kunne bruge mahalanopis afstand