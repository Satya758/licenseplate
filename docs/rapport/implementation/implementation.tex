\section{Implementering}
\label{sec:implementation}

I dette afsnit gennemgår vi implementeringssdetaljer i de funktioner som vores system består af. I flere af funktionerne har vi brugt Matlabs indbyggede komandoer, frem for at skrive egne implementationer. F.eks. har vi brugt Matlabs komandoer i forbindelse arbejdet med sammenhængende komponenter og filtrering af bileder. I det første underafsnit gennemgår vi nogle egenudviklede hjælpefunktioner som bruges flere steder i systemet. Dernæst gennemgår vi funktionerne til lokalisering af nummerplader, separation af tegn og til sidst funktionerne til genkendelse af tegn.

ORIGO: ER DET IKKE NÆRMERE AT VI ARBEJDER I ET ANDET KVARTIL(ELLER HVAD DET NU HEDDER).
Det skal bemærkes at koordinatsystemet der bruges i Matlab ikke har origo i det samme punkt som det man kender som et almindeligt koordinatsystem. Origo ligger derimod i øverste venstre hjørne (normalt ligger det i nederste venstre hjørne). Desuden er koordinaterne til origo i Matlab 1,1 og ikke 0,0. y-koordinaten til et punkt i Matlab angives normalt først, så en pixel i et billede refereres til med koordinaterne y,x i modsætning til den oftest anvendte rækkefølge x,y.

%%%%%%%%%%%%%%%%%%%%%%%%
%%% HJÆLPEFUNKTIONER %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hjælpefunktioner}
De følgende funktioner bruges af flere andre funktioner i systemet hvorfor vi har valgt at beskrive dem først. Vi har valgt kun et beskrive de funktioner vi finde særligt interesante.

\subsubsection{Hjælpefunktion 1}
BinImgCleanup
\subsubsection{Hjælpefunktion 2}
GetBestCandidate
\subsubsection{Hjælpefunktion 3}
ContrastStretch
\subsubsection{Hjælpefunktion 4}
WhiteLine 
\subsubsection{Hjælpefunktion 3}
Distribution

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LOKALISERING AF NUMMERPLADER %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lokalisering af nummerplader}
I de følgende afsnit gennemgår vi væsentlige implementeringssdetaljer i de funktioner vi bruger til lokalisering af nummerplader. De tager alle stien til et \textit{JPEG}-billede som inddata og leverer koordinater til en enkelt nummerpladekandidat samt dennes point som uddata. Koordinaterne der beskriver nummerpladekandidatens position i inddata-billedet angives i rækkefølgen: Mindste \textit{x}-værdi, største \textit{x}-værdi, mindste \textit{y}-værdi og største \textit{y}-værdi. Hvis en funktion ikke kan finde en nummerpladekandidat returneres et koordinatsæt hvor alle værdier er $0$.

I metoderne til lokalisering af nummerplader, nedskalerer vi billederne til en fjerdedel. Det vil sige at opløsningen bliver $256 \times 192$ pixels i stedet for $1024 \times 768$ pixels. Den lavere opløsning gør billederne langt hurtigere at arbejde med. Da vi ikke arbejder med anaylse af teksten på nummerpladen i disse metoder, men blot forsøger at udpege områder der indeholder nummerplader, bekymrer vi os ikke om hvorvidt nummerpladens tegn kan læses i billeder med denne lave opløsning.


Ofte udvider vi kandidatområdet før vi returnerer det for at få hele pladen med. Det er vigtigt for at senere at kunne rotere da dette kræver tilstædeværelsen af markante linier der markerer pladens over- og underkant. Vi vil hellere returnere områder der er lidt for store end områder der er lidt for små.% (mere om dette i afsnit \vref{sec:implementation/sep/rotation}).

Når vi omdanner gråtonebilleder til binærebilleder har vi, med mindre andet er beskrevet, brugt Matlabs greythresh-kommando til at udregne den værdi der afgør hvilke pixels der bliver hvide og hvilke der bliver sorte i det binære billede.

\subsubsection{Analyse af interesseområder}
\label{sec:imp:BinImgCleanup}
Analysen af de binære billeder der markerer interesseområder varetages af funktionen \textit{BinImgCleanup} hvis kildekode findes i afsnit \vref{BinImgCleanup}. Denne funktion bliver brugt af alle de fem metoder vi bruger til at lokalisere nummerplader.

Funktionen tager et binært billede samt en skaleringsværdi som inddata, og returner et binært billede hvor de områder der sandsynligvis ikke er nummerpladeområder er fjernet som beskrevet i afsnit \vref{sec:BinImgCleanup}.

Det er nødvendigt at angive en skaleringsværdien da vi i programmet har defineret hvor høje og brede nummerplader maksimalt må være som heltalsvariable. Da disse værdier er baseret på analyse af billeder med en opløsning på $1024 \times 768$ pixels har vi behov for at gøre disse variable mindre når man arbejder på billeder med en lavere opløsning. Hvis man f.eks. giver funktionen et binært billede med en opløsning på $512 \times 384$ skal skaleringsværdien være $0.50$ da billedets højde og bredde er halvt så store, hvorimod den skal være $1.0$ hvis opløsningen er $1024 \times 768$ da variablene ikke skal ændres og derfor ganges med en.

DER SKAL STÅ NOGET OM CONNECTED COMPONENTS!!

\subsubsection{Valg af bedste nummerpladekandidat}
\label{sec:imp:GetBestCandidate}
DEN SKAL JO OGSÅ BESKRIVES FØR METODERNE.
NYT NAVN.


%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Metode: Områder domineret af lyse gråtoner}
Metoden hvor vi førsøger at finde nummerplader ved at kigge på grå områder i farvebilleder er implementeret i funktionen \textit{DetectSameness} hvis kildekode findes i afsnit \vref{code:DetectSameness}. Funktionens eneste argument er stien til et farvebillede i \textit{JPG}-format i en opløsning på $1024 \times 768$ pixels. Programmet udfører følgende trin:

\paragraph{Klargørelse af originalbillede}
Billedet indlæses og nedskaleres til en fjerdedel. 

\paragraph{Skab binært billede}
På baggrund formlen i afsnit \ref{sec:DetectSameness} danner vi et binært billede hvor de områder hvor lysere gråtoner dominerer i originalbilledet er markeret.

\paragraph{Manipuler binært billede}
For at forsøge at undgår at nummerpladeområdet er forbundet med andre områder, trækker vi alle områder i det binære billede en anelse sammen. Vi bruger Matlabs funktion \textit{imerode} med et kvadrat på $2 \times 2$ pixels som figur. Dette trin kan muligvis have delt nummerpladområdet op i flere områder. For igen at have et samlet nummerpladeområde, udvidder vi alle områder i det binære billede med Matlabs \textit{imdilate}-funktion. Denne gang bruger vi et liggende rektangel med højden 2 og bredden 4 som figur. Vi bruger denne liggende figur da vi ønsker at forbinde områder som ligger ved siden af hinanden, dele af nummerpladen, men vil undgå at forbinde områder der ligger over og under hinanden. 

OVERVEJ ILLU FRA: http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Morpholo.html

\paragraph{Fjern uniteressante områder fra binært billede}
I det binære billede er der nu en masse områder som helt sikkert ikke kan være nummerpladen. Et helt oplagt eksempel er områder der kun består af ganske få pixels. Vi sletter alle de områder vi vurderer som uinteresant ved at kalde funktionen \textit{BinImgCleanup} som tidligere beskrevet i \vref{sec:imp:BinImgCleanup} med det binære billede som argument.


\paragraph{Vælg den bedste nummerpladekandidat}
For at finde den bedste nummerpladekandidate i det nu "rensede" binære billede kalder vi funktionen \textit{GetBestCandidate} som tidligere beskrevet i afsnit \vref{sec:imp:GetBestCandidate}. Funktionen returnerer koordinater og point for den nummerpladekandidat der har fået færrest point. 


\paragraph{Returner resultat}
For at forsøge at sikres os at koordinaterne dækker hele nummerpladeområdet, udvidder vi området en smule før vi returnerer det og de tilhørende point fra det tidligere trin. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Metode: Områder med høj kontrast}
Metoden hvor vi forsøger at finde nummerplader ved at markere områder med høj kontrast er implementeret i funktionen \textit{DetectContrastAvg} hvis kildekode findes i afsnit \vref{code:DetectContrastAvg}. Funktionens eneste argument er stien til et farvebillede i \textit{JPG}-format i en opløsning på $1024 \times 768$ pixels. Programmet udfører følgende trin:

\paragraph{Klargørelse af originalbillede}
Billedet indlæses og konverteres fra \textit{RGB} til 256 gråtoner. Herefter nedskaleres det til en fjerdedel. DER ER LOG I KODEN. VI GØR BILLEDET LYSERE. BESKRIV!

\paragraph{Udregn gradienter}



\begin{description}
\item[5.] Udregn gradienter.
\item[6.] Udregn gradienters vinkler.
\item[7.] Udregn gradienters længder og normaliser dem så de største har længden 1,0.
\item[8.] Udvælg gradienter hvis normaliserede længde er 0,25 eller mere.
\item[9.] Skab et billede ved at indsætte intensitetet af punkter der har "liggende" gradienter. Det vil sige, gradienter der har en vinkel på mellem 0 og 30 i forhold til vandret. Hvis gradienten er en af de længste i billedet, indsættes den fordoblede intensitet.
\item[10.] Kør et filter som udtværer billedet og forbinder områder der ligger ved siden af hinanden som beskrevet i afsnit \ref{sec:DetectContrastAvg}.
\item[11.] Skab et binært billede udfra det filtrerede billede af de "liggende" gradienter. 
\item[12.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[13.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[14.] Returner koordinater.
\end{description}



\paragraph{Manipuler binært billede}
For at forsøge at undgår at nummerpladeområdet er forbundet med andre områder, trækker vi alle områder i det binære billede en anelse sammen. Vi bruger Matlabs funktion \textit{imerode} med et kvadrat på $2 \times 2$ pixels som figur. Dette trin kan muligvis have delt nummerpladområdet op i flere områder. For igen at have et samlet nummerpladeområde, udvidder vi alle områder i det binære billede med Matlabs \textit{imdilate}-funktion. Denne gang bruger vi et liggende rektangel med højden 2 og bredden 4 som figur. Vi bruger denne liggende figur da vi ønsker at forbinde områder som ligger ved siden af hinanden, dele af nummerpladen, men vil undgå at forbinde områder der ligger over og under hinanden. 

OVERVEJ ILLU FRA: http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Morpholo.html

\paragraph{Fjern uniteressante områder fra binært billede}
I det binære billede er der nu en masse områder som helt sikkert ikke kan være nummerpladen. Et helt oplagt eksempel er områder der kun består af ganske få pixels. Vi sletter alle de områder vi vurderer som uinteresant ved at kalde funktionen \textit{BinImgCleanup} som tidligere beskrevet i \vref{sec:imp:BinImgCleanup} med det binære billede som argument.


\paragraph{Vælg den bedste nummerpladekandidat}
For at finde den bedste nummerpladekandidate i det nu "rensede" binære billede kalder vi funktionen \textit{GetBestCandidate} som tidligere beskrevet i afsnit \vref{sec:imp:GetBestCandidate}. Funktionen returnerer koordinater og point for den nummerpladekandidat der har fået færrest point. 


\paragraph{Returner resultat}
For at forsøge at sikres os at koordinaterne dækker hele nummerpladeområdet, udvidder vi området en smule før vi returnerer det og de tilhørende point fra det tidligere trin. 


Vi bruger Matlabs funktioner til at udregne gradienterne samt anvende filteret.


Pladerne bliver meget lave da vi kun kigger på kontrasten. Vi får altså ikke den hvide over- og underkant med. Derfor udvider vi kandidaten med 15 pixels på over- og underkanten. 


\subsubsection{Metode: Frekvensanalyse}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectPlateness}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[6.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I punkt 8 returnerer vi et kandidatområde der er gjort højere da vi ellers ofte ikke får hele pladen med, da frekvensen i det hvide område over og under tegnene i nummerpladen er lav og dermed ikke karateristisk for en nummerplade.

Metoden bliver dårligere jo mere man skalerer billedet ned da tegn i nummerpladerne ikke længere er klart separeret. Vi burde nok køre dette på større billeder.
Vi bruger funktionen plateness. Den kunne være mere robust.

FIGURER AF HISTOGRAMMER OG LIGN.


\subsubsection{Metode: Skru op for Kontrast}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectCStretch}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[8.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I trin 4 bruger vi hjælpefunktionen \textit{ContrastStretc} i en dobbeltløkke der behandler billedet i kvadratiske blokke af 4x4 pixels. Når vi skaber det binære billede i trin 5 bruger vi en grænseværdi på 0,65 der gør at det hvide i det binære billede skal være pixels der er noget over middelværdien i det filtrerede billede. Vores erfaring er, at vi i mange tilfælde kan separere nummerpladerne bedre med denne grænseværdi.

ER DET BEDRE AT GANGE GRAYTHRESH LIDT OP??    
GØR VI KANDIDATEN STØRRE?
Måske kunne vi opnå bedre resultater ved at bruge filter frem for blok, men blok er meget hurtigere.


%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Metode: Kvantifisering}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectQuant}.
\item[5.] Sæt antal forskellige intensiteter i billedet ned til 7.
\item[6.] Lav et binært billede for hver af intensiteterne.
\item[7.] For hver intensitet, slet områder i det binære billeder der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[8.] Gør områderne i de binære billeder lidt mindre.  
\item[9.] Slå de binære billeder sammen til et enkelt binært billede. 
\item[10.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[11.] Udvid koordinaterne for den valgte nummerpladekandidat.
\item[12.] Returner koordinater.
\end{description}

I trin 4 dividerer vi alle intensiteterne i billedet med 43 og runder af for at sætte antallet af mulige intensitetsværdier ned til 7 i intervallet 1 til 7. De binære billeder i trin 6 gemmer vi en matrix med dimensionerne \textit{[billedehøjde, billedbrede, antal intensiteter]}. I trin 8 gør vi områderne mindre så se ikke smelter sammen med andre områder i trin 9.

METODEN ER DÅRLIG PÅ HVIDE BILER



%\subsubsection{Metode: Histogram}

\subsubsection{Endeligt valg af nummerpladekandidat}
\begin{description}
\item[1.] Indlæs billede.
\end{description}


Illustrer hvordan vi afgør (u)enighed. 

VI RETURNERER DEN STØRST MULIGE PLADE

\subsubsection{Mulige forbedringer}
Vi kunne arbejde mere med manipulation af de binære billeder før vi renser dem. Vi kunne arbejde mere med støjfiltrering etc. altså preprocessing af billederne. Citer folk der gør det. Skriv også hvad de gør.
Man kunne have taget højde for at de forskelleige metoder returnerer områder af forskellig bredde og intensitet.


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SEPARATION AF TEGN %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Separation af tegn}

I de følgende afsnit gennemgår vi væsentlige implementeringssdetaljer i de funktioner vi bruger til separation af tegn. 

\subsubsection{Rotation}
\label{sec:implementation/sep/rotation}

Metoden til rotation er implementeret i funktionen \textit{RotatePlateRadon}, hvis kildekode findes i afsnit \vref{code:RotatePlateRadon}. Metoden tager stien til et \textit{JPEG}-billede samt koordinaterne for nummerpladen i billedet som indata. Funktionen returnerer billedet af den roterede plade samt dennes (roterede) koordinater i original billedet. Funktionens forløb er som følger:

\paragraph{1. Billedet af nummerpladen "tages ud" af originalbilledet.}
\paragraph{2. Billedet af pladen kant-detekteres:}
For at finde pladens rotation er det nødvendigt at finde kanterne i billedet af nummerpladen. Matlab funktionen \textit{edge} bruges til at lave et binært billede hvor alle horisontale kanter er markeret. De vertikale kanter markeres ikke. På denne måde kan vi nøjes med at analysere én dimension ved brug af Radon transformationen. I denne sammenhæng er vi interesseret i de kanter der er (næsten) horisontale, da det med stor sandsynlighed er de "lange" kanter i nummerpladens rektangel. Det vil være et problem, hvis nummerpladen "klippes" så tæt at den øvre eller nedre kant af nummerpladen ikke kommer med i billedet. I dette tilfælde er det meget usikkert om de horisontale kanter i nummerpladens tegn vil være kraftige nok til at Radon transformationen vil "bruge" disse kanter til at finde den tydeligste kant.

\paragraph{3. Radon matricen for kant-billedet findes ved brug af Matlab funktionen \textit{radon}.}

\paragraph{4. Den maksimale værdi i Radon matricen findes og rotationsvinklen registres:}
Rotationsvinklen svarer til ...

\paragraph{5. Billedet af nummerpladen roteres ved brug af \textit{imrotate}.}
\paragraph{6. Koordinaterne til den roterede plade findes ved brug af en rotationsmatrix.}

\subsubsection{Separation}

Metoderne til separation af tegn tager et billede af en nummerplade samt koordinaterne til denne plade i orginalbilledet som inddata, og returnerer syv billeder af de syv tegn (hvis syv tegn er fundet), koordinaterne til disse tegn i orginalbilledet samt antallet af fundne tegn som uddata.

\subsubsection*{Sammenhængende komponenter}

Denne metode er implementeret i funktionen \textit{CharSeparationCC}, hvis kildekode findes i afsnit \vref{code:CharSeparationCC}. Funktionen forløber således:

\paragraph{1. Billedet af pladen omdannes til gråtone.}

\paragraph{2. Billedet laves om til sort-hvid, "roughly" og indskrænkes til den største komponent:}
De billeder der i denne del af systemet modtages fra metoderne til identificering af nummerplader er ikke nødvendigvis udskåret så nøjagtigt at nummerpladen dækker hele billedet. Billedet kan derfor indeholde elementer som ikke er en del af nummerpladen (eksempelvis et klistermærke som sidder på bilen). Derfor er det hensigtsmæssigt, når tegnene i nummerpladen skal separeres, at indskrænke billedet så det mest muligt kun forestiller nummerpladen. Da nummerpladen med sandsynlighed er det mest lyse element i billedet, gøres dette ved at gøre billedet binært og indskrænke det til det største hvide område i billedet. Dette gøres ved hjælp af Matlab funktionen im2bw, hvor grænsen for hvilke intensitetsværdier der skal være hvide i det binære billede sættes under middel. På denne måde sikrer vi os, at nummerpladen vil være hvid og at den ikke bliver sort (SKRIV OM).

\paragraph{3. Kontrast..:}
For at få nummerpladens tegn til at adskille sig mest muligt fra pladens hvide baggrund skal billedet kontrastforstærkes. Til at kontrastforstærke bruges hjælpefunktionen \textit{ContrastStretch}. Denne funktion udføres i blokke så man udover den forstærkede kontrast mellem tegnene og baggrunden også opnår forstærket kontrast mellem støj (f.eks. snavs på nummerpladen) og baggrunden. Hvis denne støj er tæt på et tegn vil der være chance for at tegnet "gror sammen" med støjen og derfor bliver sorteret fra når de sammenhængende komponenter analyseres. Hvis kontrasten forstærkes i blokke er der dog en mulighed for at snavsen og tegnets kant vil blive adskilt. Størrelsen af blokkene der arbejdes med er bestemt eksperimentielt.

\paragraph{4. Tynde komponenter i toppen og i siderne af billedet fjernes:}
Når det binære billede er dannet opstår der igen en mulighed for at minimere tilfælde hvor tegn er groet sammen med eksempelvis nummerpladens kant. Se et eksempel nedenfor... Når dette .... Derfor slettes alle pixels som har en tom plads på begge sider i den øverste 1/3 af billedet, samt i den yderste 1/10 i både højre og venstre side.

BILLEDE MED NUMMERPLADE SOM ER I SKYGGE FOROVEN SAMT BINÆRT BILLEDE HVOR TYNDE KOMPONENTER KAN FJERNES

Derudover slettes alle pixels i de rækker af billedet som ikke har mindst en 1/10 eller højst 2/3 af alle pixels i billedets bredde sat. Dette gøres fordi en linie som går i gennem alle tegn vil ligge i dette område.

BESKRIV PROBLEM MED TEGNET K

\paragraph{5. Horisontale linier med meget lidt hvid, eller meget hvid gøres helt sorte:}
Beskrivelse...

\paragraph{6. Det sort-hvide billede laves til et sammenhængende-komponenter-billede.}
\paragraph{7. For små og for store komponenter fjernes.}
I næste del af funktionen frasorteres alle de sammenhængende komponenter der er for små eller for store.

\paragraph{8. Grupper på syv komponenter samles hvor alle syv komponenter har samme højde og er i samme højde.}

Så findes der grupper af syv sammenhængende komponenter hvor elementerne i hver gruppe skal være ca. lige høje og befinde sig i ca. samme højde.

\paragraph{9. Afstandene mellem komponenter i hver gruppe udregnes og en "god" gruppe vælges:}
Til sidst analyseres disse grupper og hvis komponenterne i én af grupperne har de rette afstande i mellem sig, vælges elementerne i gruppen som tegnene.

NOGET MED AT TEGNENE SKÆRES "TÆT"	

\subsubsection*{Bjerg/dal}

Denne metode er implementeret i funktionen \textit{CharSeparationPTV}, hvis kildekode findes i afsnit \vref{code:CharSeparationPTV}.


Nummerpladens signatur fås ved at summere projektionerne af alle rækkerne i billedet. Hvis denne signatur præsenteres som en graf i et koordinatsystem vil der forekomme toppe i de kolonner hvor der høj intensitet. Idéen er så at udvælge de otte højeste toppe som de otte steder i x-planen der skal skæres ved.

KONTRAST?

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Pladens signatur findes ved at opsummere intensitetsværdierne i billedet af nummerpladen omdannet til gråtone. Hvis man betragter signaturen som en graf vil den være "hakket" på grund af støj i billedet (dvs. det er kun i teorien at billedet kun indeholder en hvid baggrund og nogle mørke bogstaver, hvilket ville give en perfekt graf). Signaturen skal derfor udglattes. Dette gøres ved at tildele det indeværende punkt på grafen middelværdien af punktets nærområde. EKSEMPEL PÅ UDREGNING? Et eksempel på en "rå" graf og samme graf, udglattet ses i Figur \vref{fig:smoothSig}.

EKSEMPEL PÅ HAKKET SIGNATUR OG UDGLATTET SIGNATUR

\begin{figure}[htp]
\label{fig:smoothSig}
\caption{bla}
\end{figure}

For at finde de toppe hvor der skal skæres, leder vi efter punkter, $x$ i signaturgrafen hvor de $n$ forrige punkter har haft stigende værdier op til $x$ og hvor de efterfølgende $n$ punkter har faldende værdier. DETTE GØR VI IKKE I PRAKSIS! SKAL LAVES OM. De otte $x$'er som har de otte højeste værdier vælges som de otte skæringspunkter.

NOGET OM HVORDAN VI FINDER TOP OG BUND BESKÆRING


\subsubsection{Mulige forbedringer}
DER MÅ VÆRE MANGE KOMMENTARER TIL HVORDAN VI KAN GØR BJERG/DAL BEDRE

I funktionen der bruger sammenhængende komponenter findes der flere statiske variable, som eksempelvis størrelsen af de blokke der kontrastforstærkes i, komponenternes minimum bredde osv. Disse variable kunne være lavet dynamisk, men de er ret gode nu og derfor har vi ladet dem være. SKRIV DET SIDSTE OM.

CONCOMP: BESKREVET I KWAS: MAN KU FJERNE KANTER FØR ANALYSE?

SKALERING KAN FORBEDRE HASTIGHED? PERFORMANCE?

MEDIAN FILTER ELLER ANDRE FILTRE? LYSFORSTÆRKNING?


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GEKENDELSE AF TEGN %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Genkendelse af tegn}

\subsubsection{Middelvektorer}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Implementationen af metoden til tegngenkendelse ved hjælp af vektor analyse findes i filerne \textit{GetMeanVectors.m} og \textit{ReadPlateFV.m}.

For at disse to funktioner/metoder skal fungere sammen er det nødvendigt at længden, $d$ af middelvektorerne er den samme i begge funktioner. Man bør eksperimentere med størrelsen af $d$.

\textit{GetMeanVectors.m} udarbejder en matrix bestående af middelvektorer for hvert lovligt tegn. Hver vektor vil have længden $d$. Denne matrix bruges af \textit{ReadPlateFV.m}: Hvert inputbillede omformes til en vektor af længden $d$ og herefter løbes middelvektor-matrixen igennem. Afstanden fra det omformede billede til hver middelvektor noteres og tegnhitlisten udarbejdes på baggrund af disse afstande. Sammen med denne hitliste returneres afstandene, så disse kan bruges i forbindelse med syntaks analyse.
Som input modtager funktionen en mængde billeder af manuelt sorterede tegn.

Hvert billede laves til et kvadrat. Ved at lave middelvektorer på træningssættet kan vi se at man ikke kan have vektorer af længden 4, da flere bogstavs vektorer så vil være de samme (nemlig 0 0 0 0). Afprøv med andre længder.

\textit{ReadPlateFV.m}...

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Sum-billeder}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Syntaks analyse}

Metoden til syntaks analyse tager tegnhitlisterne for de syv tegn, listerne over afstandene til middelvektorerne samt et "maksimal-hit-nummer" som inddata. Uddata er en syntaksanalyseret tegnfølge samt en vektor indeholdende de hits der er blevet brugt til at lave denne tegnfølge. Implementeringen af metoden til syntaksanalyse findes i filen \textit{SyntaxAnalysis.m}.

Funktionens forløb er som følger:

\begin{description}
\item[1.] Hitlisterne for tegnene på de to første pldser gennemløbes indtil der står to bogstaver
\item[2.] De to tegn på de første to pladser analyseres og udskiftes om nødvendigt
\end{description}

Hvis der i på tegnfølgens to første positioner fremkommer en ulovlig bogstavkombination fås et problem: Hvilket tegn skal man forsøge at udskifte så en lovlig kombination forekommer? Dette gøres på baggrund af billedets (af tegnet) afstand til de to middelvektorer: Den middelvektor der er længst væk har størst sandsynlighed for at være et forkerte bogstav, hvorfor denne skiftes ud.

\begin{description}
\item[3.] Hitlisterne for tegnene på de fem sidste pladser gennemløbes indtil der står fem tal
\item[4.] De to tegn på plads nr. tre og fire analyseres og udskiftes om nødvendigt
\end{description}

Bla bla

\begin{description}
\item[5.] De valgte hitnumre analyseres. Hvis et nummer er for højt i forhold til det maksimale, returnes et "\_" tegn på den givne plads
\end{description}

\subsubsection{Mulige forbedringer}
Når der eksempelvis forekommer en ulovlig bogstavkombination i syntaksanalysen udskiftes det tegn som har den længste afstand til middelvektoren hver gang. Det vil sige at kun det ene tegn vil blive udskiftet (tegnets vektor er til at starte med den vektor der ligger længest væk og dette vil ikke ændre sig, da man hele tiden vælger vektorer der ligger længere og længere væk). En anden mulighed kunne være at man skifter mellem at udskifte det ene og det andet tegn Eksempel: tegnfølgen \textbf{AB} er fundet, men denne er ulovlig. Først udskiftes \textbf{B}, da denne ligger længst væk. En ny tegnfølge \textbf{AC} findes, men denne er også ulovlig. I stedet for at udskifte tegnet på 2. position igen (\textbf{C}) udskiftes \textbf{A} og \textbf{B} sættes tilbage på 2. position.

Man kunne bruge mahalanopis afstand