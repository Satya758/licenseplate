\section{Implementation}
\label{sec:implementation}

Intro til dette afsnit.. ala "I de følgende afsnit gennemgår vi væsentlige implementationsdetaljer i de funktioner vi bruger..."

DET HEDDER IMPLEMENTERING

Noget med at vi har brugt Matlabs egne metoder hvis vi kendte til komandoer for det vi gerne ville opnå. F.eks. filter og blokprocess.

Koordinatsystemet er matlabstyle. 1,1 er øverst til venstre. Y angives normal først så en pixel i et billede reffereres til med koordinaterne y,x i modsætning til den oftest anvendte rækkefølge x,y. 

\subsection{Hjælpefunktioner}
Vi har hjælpefunktioner... blah.. generelle.. bruges af flere funktioner.
\subsubsection{Hjælpefunktion 1}
BinImgCleanup
\subsubsection{Hjælpefunktion 2}
GetBestCandidate

\subsection{Lokalisering af nummerplader}
I de følgende afsnit gennemgår vi væsentlige implementationsdetaljer i de funktioner vi bruger til lokalisering af nummerplader. De tager alle stien til et \textit{JPEG}-billede som input og leverer koordinater til en enkelt nummerpladekandidat som uddate. Koordinaterne der beskriver nummerpladekandidatens position i inddata-billedet angives i rækkefølgen: Mindste x-værdi, største x-værdi, mindste y-værdi og største y-værdi. Hvis en funktion ikke kan finde en nummerpladekandidat returneres et koordinatsæt hvor alle værdier er 0.

Ofte udvider vi kandidatområdet for at få hele pladen med. Det er vigtigt for at kunne rotere.

Vi har brugt greythresh med mindre andet er beskrevet.
\subsubsection{Metode: Områder domineret af lyse gråtoner}
Denne metode er implementeret i funktionen \textit{DetectSameness} hvis kildekode findes i afsnit \vref{code:DetectSameness}. Programmet udfører følgende trin:

\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Skab binært billede som beskrevet i \ref{sec:DetectSameness}.
\item[5.] Sammentræk områder i det binære billede\footnote{Eng.: Erode}
\item[6.] Forbind områder der ligger ved siden af hinanden i det binære billede\footnote{Eng.: Dilate}.
\item[7.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[8.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[9.] Returner koordinater.
\end{description}

I trin nr. 5 sammentrækker vi med et kvadratisk element. I trin nr. 6 forbinder vi områder der ligger ved siden af hinanden ved at udvide med et liggende rektangulært element. 


\subsubsection{Metode: Områder med høj kontrast}
Denne metode er implementeret i funktionen \textit{DetectContrastAvg} hvis kildekode findes i afsnit \vref{code:DetectContrastAvg}. Programmet udfører følgende trin:

\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[3.] SKAL DER VÆRE LOG HER? DET ER DER I KODEN!!
\item[4.] Gør billedet lysere ved at dividere intensiteterne med en konstant.
\item[5.] Udregn gradienter.
\item[6.] Udregn gradienters vinkler.
\item[7.] Udregn gradienters længder og normaliser dem så de største har længden 1,0.
\item[8.] Udvælg gradienter hvis normaliserede længde er 0,25 eller mere.
\item[9.] Skab et billede ved at indsætte intensitetet af punkter der har "liggende" gradienter. Det vil sige, gradienter der har en vinkel på mellem 0 og 30 i forhold til vandret. Hvis gradienten er en af de længste i billedet, indsættes den fordoblede intensitet.
\item[10.] Kør et filter som udtværer billedet og forbinder områder der ligger ved siden af hinanden som beskrevet i afsnit \ref{sec:DetectContrastAvg}.
\item[11.] Skab et binært billede udfra det filtrerede billede af de "liggende" gradienter. 
\item[12.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[13.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[14.] Returner koordinater.
\end{description}

Vi bruger Matlabs funktioner til at udregne gradienterne samt anvende filteret.


Pladerne bliver meget lave da vi kun kigger på kontrasten. Vi får altså ikke den hvide over- og underkant med. Derfor udvider vi kandidaten med 15 pixels på over- og underkanten. 


\subsubsection{Metode: Frekvensanalyse}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectPlateness}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[6.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I punkt 8 returnerer vi et kandidatområde der er gjort højere da vi ellers ofte ikke får hele pladen med, da frekvensen i det hvide område over og under tegnene i nummerpladen er lav og dermed ikke karateristisk for en nummerplade.

Metoden bliver dårligere jo mere man skalerer billedet ned da tegn i nummerpladerne ikke længere er klart separeret. Vi burde nok køre dette på større billeder.
Vi bruger funktionen plateness. Den kunne være mere robust.

FIGURER AF HISTOGRAMMER OG LIGN.


\subsubsection{Metode: Skru op for Kontrast}
\begin{description}
\item[1.] Indlæs billede.
\item[2.] Konverter til gråtoner.
\item[3.] Nedskaler billede.
\item[4.] Filtrer billede som beskrevet i \ref{sec:DetectCStretch}.
\item[5.] Skab binært billede ud fra det filtrerede billede.
\item[8.] Slet områder i det binære billede der sandsynligvis ikke er nummerplader ved at bruge funktionen \textit{BinImgCleanup}.
\item[7.] Vælg nummerpladekandidat ved at bruge funktionen \textit{GetBestCandidate}.
\item[8.] Returner koordinater.
\end{description}

I trin 4 bruger vi hjælpefunktionen \textit{ContrastStretc} i en dobbeltløkke der behandler billedet i kvadratiske blokke af 4x4 pixels. Når vi skaber det binære billede i trin 5 bruger vi en grænseværdi på 0,65 der gør at det hvide i det binære billede skal være pixels der er noget over middelværdien i det filtrerede billede. Vores erfaring er, at vi i mange tilfælde kan separere nummerpladerne bedre med denne grænseværdi.

ER DET BEDRE AT GANGE GRAYTHRESH LIDT OP??    
GØR VI KANDIDATEN STØRRE?
Måske kunne vi opnå bedre resultater ved at bruge filter frem for blok, men blok er meget hurtigere.

\begin{description}
\item[1.] Indlæs billede.
\end{description}


\subsubsection{Metode: Kvantifisering}
\begin{description}
\item[1.] Indlæs billede.
\end{description}

METODEN ER DÅRLIG PÅ HVIDE BILER

PÅ ET TIDSPUNKT BLIVER DER RUNDET NED. UNDERSØG OM DET SKA VÆRE SÅDAN. DET VILLE VEL VÆRE BEDRE AT BARE RUNDE AF?


%\subsubsection{Metode: Histogram}

\subsubsection{Endeligt valg af nummerpladekandidat}
\begin{description}
\item[1.] Indlæs billede.
\end{description}


Illustrer hvordan vi afgør (u)enighed. 

GØR NOGET I KODEN DA RESULTATET 2 vs 2 kandidater er random.

VI RETURNERER DEN STØRST MULIGE PLADE

\subsubsection{Mulige forbedringer}
Vi kunne køre GetBestCandidate når der er uenighed i DetectMain.
Vi kunne lave et pointsystem i GetBestCandidate.


%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Separation}

\subsubsection{Rotation}
\label{sec:implementation/sep/rotation}

Metoden til rotation er implementeret i funktionen \textit{RotatePlateRadon}, hvis kildekode findes i afsnit \vref{code:RotatePlateRadon}. Metoden tager stien til et jpg-billede samt koordinaterne for nummerpladen i billedet som input. Funktionen returnerer billedet af den roterede plade samt dennes (roterede) koordinater i original billedet.

\begin{description}
\item[1.] Et billede af kun pladen, plukkes ud
\item[2.] Kanterne findes i billedet af pladen
\end{description}
For at finde pladens rotation er det nødvendigt at finde kanter i billedet af en nummerplade. Matlab funktionen edge bruges til at lave et binært billede hvor alle horisontale kanter er markeret. De vertikale kanter markeres ikke, da dette ville give en større mulighed for at radon transformationen finder den tydligste kant i en vertikale linie i billedet. I denne sammenhæng er vi interesseret i de kanter der er (næsten) horisontale, da det med stor sandsynlighed er de "lange" kanter i nummerpladens rektangel.

\begin{description}
\item[3.] Radon matricen for kant-billede findes ved brug af funktionen \textit{radon}
\item[4.] Den maksimale værdi i Radon matricen findes og rotationsvinklen registres
\item[5.] Billedet af nummerpladen roteres ved brug af imrotate
\item[6.] Koordinaterne til den roterede plade findes ved brug af en rotationsmatrix
\end{description}

EVT. ILLU AF RADON? ELLER SKAL DET VÆRE I "SYSTEM" AFSNITTET?

Det vil være et problem, hvis nummerpladen "klippes" så tæt at den øvre eller nedre kant af nummerpladen ikke kommer med i billedet. I dette tilfælde er det meget usikkert om de horisontale kanter i nummerpladens tegn vil være kraftige nok til at Radon transformationen vil "bruge" disse kanter til at finde den tydeligste kant.

\subsubsection{Separation}

Metoderne til separation af tegn tager et billede af en nummerplade samt koordinaterne til denne plade i orginalbilledet som input, og returnerer syv billeder af de syv tegn (hvis syv tegn er fundet), koordinaterne til disse tegn i orginalbilledet samt antallet af fundne tegn som uddata.

\subsubsection*{Sammenhængende komponenter}

Denne metode er implementeret i funktionen \textit{CharSeparationCC}, hvis kildekode findes i afsnit \vref{code:CharSeparationCC}.

HENVIS TIL DET TOBIAS HAR SKREVET OM CONTRAST STRETCH

\begin{description}
\item[1.] Billedet af pladen omdannes til gråtone
\item[2.] Billedet laves om til sort-hvid, "roughly" og indskrænkes til den største komponent
\end{description}
De billeder der i denne del af systemet modtages fra metoderne til identificering af nummerplader er ikke nødvendigvis udskåret så nøjagtigt at nummerpladen dækker hele billedet. Billedet kan derfor indeholde elementer som ikke er en del af nummerpladen (eksempelvis et klistermærke som sidder på bilen). Derfor er det hensigtsmæssigt, når tegnene i nummerpladen skal separeres, at indskrænke billedet så det mest muligt kun forestiller nummerpladen. Da nummerpladen med sandsynlighed er det mest lyse element i billedet, gøres dette ved at gøre billedet binært og indskrænke det til det største hvide område i billedet. Dette gøres ved hjælp af Matlab funktionen im2bw, hvor grænsen for hvilke intensitetsværdier der skal være hvide i det binære billede sættes under middel. På denne måde sikrer vi os, at nummerpladen vil være hvid og at den ikke bliver sort (SKRIV OM).

\begin{description}
\item[3.] Kontrast..
\end{description}



For at få nummerpladens tegn til at adskille sig mest muligt fra pladens hvide baggrund skal billedet kontrastforstærkes. Dette gøres i blokke så man udover den forstærkede kontrast mellem tegnene og baggrunden også opnår forstærket kontrast mellem støj (f.eks. snavs på nummerpladen) og baggrunden. Hvis denne støj er tæt på et tegn vil der være chance for at tegnet "gror sammen" med støjen og derfor bliver sorteret fra når de sammenhængende komponenter analyseres. Hvis kontrasten forstærkes i blokke er der dog en mulighed for at snavsen og tegnets kant vil blive adskilt. Størrelsen af blokkene der arbejdes med bestemmes eksperimentielt.

\begin{description}
\item[4.] Tynde komponenter i toppen og i siderne af billedet fjernes
\end{description}

Når det binære billede er dannet opstår der igen en mulighed for at minimere tilfælde hvor tegn er groet sammen med eksempelvis nummerpladens kant. Se et eksempel nedenfor... Når dette .... Derfor slettes alle pixels som har en tom plads på begge sider i den øverste 1/3 af billedet, samt i den yderste 1/10 i både højre og venstre side.

BILLEDE MED NUMMERPLADE SOM ER I SKYGGE FOROVEN SAMT BINÆRT BILLEDE HVOR TYNDE KOMPONENTER KAN FJERNES

Derudover slettes alle pixels i de rækker af billedet som ikke har mindst en 1/10 eller højst 2/3 af alle pixels i billedets bredde sat. Dette gøres fordi en linie som går i gennem alle tegn vil ligge i dette område.

BESKRIV PROBLEM MED TEGNET K

\begin{description}
\item[5.] Horisontale linier med meget lidt hvid, eller meget hvid gøres helt sorte
\end{description}

Beskrivelse...

\begin{description}
\item[6.] Det sort-hvide billede laves til et sammenhængende-komponenter-billede
\item[7.] For små og for store komponenter fjernes
\end{description}

I næste del af funktionen frasorteres alle de sammenhængende komponenter der er for små eller for store.

\begin{description}
\item[8.] Grupper på syv komponenter samles hvor alle syv komponenter har samme højde og er i samme højde
\end{description}

Så findes der grupper af syv sammenhængende komponenter hvor elementerne i hver gruppe skal være ca. lige høje og befinde sig i ca. samme højde.

\begin{description}
\item[9.] Afstandene mellem komponenter i hver gruppe udregnes og en "god" gruppe vælges
\end{description}

Til sidst analyseres disse grupper og hvis komponenterne i én af grupperne har de rette afstande i mellem sig, vælges elementerne i gruppen som tegnene.

\subsubsection*{Bjerg/dal}

Denne metode er implementeret i funktionen \textit{CharSeparationPTV}, hvis kildekode findes i afsnit \vref{code:CharSeparationPTV}.


Nummerpladens signatur fås ved at summere projektionerne af alle rækkerne i billedet. Hvis denne signatur præsenteres som en graf i et koordinatsystem vil der forekomme toppe i de kolonner hvor der høj intensitet. Idéen er så at udvælge de otte højeste toppe som de otte steder i x-planen der skal skæres ved.

KONTRAST?

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Pladens signatur findes ved at opsummere intensitetsværdierne i billedet af nummerpladen omdannet til gråtone. Hvis man betragter signaturen som en graf vil den være "hakket" på grund af støj i billedet (dvs. det er kun i teorien at billedet kun indeholder en hvid baggrund og nogle mørke bogstaver, hvilket ville give en perfekt graf). Signaturen skal derfor udglattes. Dette gøres ved at tildele det indeværende punkt på grafen middelværdien af punktets nærområde. EKSEMPEL PÅ UDREGNING? Et eksempel på en "rå" graf og samme graf, udglattet ses i Figur \vref{fig:smoothSig}.

EKSEMPEL PÅ HAKKET SIGNATUR OG UDGLATTET SIGNATUR

\begin{figure}[htp]
\label{fig:smoothSig}
\caption{bla}
\end{figure}

For at finde de toppe hvor der skal skæres, leder vi efter punkter, $x$ i signaturgrafen hvor de $n$ forrige punkter har haft stigende værdier op til $x$ og hvor de efterfølgende $n$ punkter har faldende værdier. DETTE GØR VI IKKE I PRAKSIS! SKAL LAVES OM. De otte $x$'er som har de otte højeste værdier vælges som de otte skæringspunkter.

NOGET OM HVORDAN VI FINDER TOP OG BUND BESKÆRING


\subsubsection{Mulige forbedringer}
DER MÅ VÆRE MANGE KOMMENTARER TIL HVORDAN VI KAN GØR BJERG/DAL BEDRE

\subsection{Genkendelse af tegn}

\subsubsection{Vektor}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

Implementationen af metoden til tegngenkendelse ved hjælp af vektor analyse findes i filerne \textit{GetMeanVectors.m} og \textit{ReadPlateFV.m}.

For at disse to funktioner/metoder skal fungere sammen er det nødvendigt at længden, $d$ af middelvektorerne er den samme i begge funktioner. Man bør eksperimentere med størrelsen af $d$.

\textit{GetMeanVectors.m} udarbejder en matrix bestående af middelvektorer for hvert lovligt tegn. Hver vektor vil have længden $d$. Denne matrix bruges af \textit{ReadPlateFV.m}: Hvert inputbillede omformes til en vektor af længden $d$ og herefter løbes middelvektor-matrixen igennem. Afstanden fra det omformede billede til hver middelvektor noteres og tegnhitlisten udarbejdes på baggrund af disse afstande. Sammen med denne hitliste returneres afstandene, så disse kan bruges i forbindelse med syntaks analyse.
Som input modtager funktionen en mængde billeder af manuelt sorterede tegn.

\textit{ReadPlateFV.m}...

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Metode hvor der and'es}

\begin{enumerate}
\item funktion pkt 1
\item funktion pkt 2
\item funktion pkt n
\end{enumerate}

\subsubsection{Syntaks analyse}

Metoden til syntaks analyse tager tegnhitlisterne for de syv tegn, listerne over afstandene til middelvektorerne samt et "maksimal-hit-nummer" som input. Uddata er en syntaks analyseret tegnfølge samt en vektor over hvilke hits der er blevet brugt til at lave denne tegnfølge. Implementationen af metoden til syntaks analyse findes i filen \textit{SyntaxAnalysis.m}.

\begin{description}
\item[1.] Hitlisterne for tegnene på de to første pldser gennemløbes indtil der står to bogstaver
\item[2.] De to tegn på de første to pladser analyseres og udskiftes om nødvendigt
\end{description}

Hvis der i på tegnfølgens to første positioner fremkommer en ulovlig bogstavkombination fås et problem: Hvilket tegn skal man forsøge at udskifte så en lovlig kombination forekommer? Dette gøres på baggrund af billedets (af tegnet) afstand til de to middelvektorer: Den middelvektor der er længst væk har størst sandsynlighed for at være et forkerte bogstav, hvorfor denne skiftes ud.

\begin{description}
\item[3.] Hitlisterne for tegnene på de fem sidste pladser gennemløbes indtil der står fem tal
\item[4.] De to tegn på plads nr. tre og fire analyseres og udskiftes om nødvendigt
\end{description}

Bla bla

\begin{description}
\item[5.] De valgte hitnumre analyseres. Hvis et nummer er for højt i forhold til det maksimale, returnes et "\_" tegn på den givne plads
\end{description}

\subsubsection{Mulige forbedringer}
I stedet for at udskifte det tegn som har den længste afstand til middelvektoren hver gang, så skal den prøve at udskifte det andet? Eksempel: tegn = AB. udskift B som ligger længst væk. Ny tegnfølge: AC er også forkert. I stedet for at udskifte C (som jo må ligge længere væk end A, da B gjorde det), udskift da A og sæt B ind i stedet. Men det giver måske ingen forskel i praksis?